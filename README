Introduction
============
This is an implementation of the algorithm described by M.M. Micheal in his 
article "Safe memory Reclamation for Dynamic Lock-Free Objects Using Atomic
Reads and Writes".

Some notes should be made about the algorithm and its implementation, which may
be important when using the library.

Global Constants
================
The algorithm describes two global constants, P and K, on which most of the
sizes of internal arrays etc. depend. P is the number of participating threads,
K is the number of hazard pointers per thread.

This assumes that you know the number of participating threads before your 
program starts - i.e. at compile time. I have found it quite impossible to 
predict the number of participating threads on a varierty of occasions, so 
I wouldn't want to impose any constant of my divising. Therefore, I have made 
the P constant a global variable which can be initialized, once, when the 
library is initialized. In future versions, the variable will really become
variable in that you can change its value during run-time, after the library
has been initiated.

It is also assumed that the number of hazard pointers per thread is known in
advance. This can only be known in the cases where your algorithm was designed
to use hazard pointers from the beginning (as is the case with M.M. Micheal's
own container algorithms) but, again, there is no way for me to predict the
number of hazard pointers you will need.

The batch size (number of pointers queued for deletion by a thread before 
the thread actually starts scanning) is also a global constant and is more
or less a function of P and K. This has also become a global variable - under
the same conditions as P and K (i.e. initialized once for the time being).

Note that the batch size (global constant R) must be greater than (and not 
equal to) P * K. If not, Scan() is not guaranteed to free up enough space
to let DeleteNode do its work properly.

The "Optimized" Version
=======================
The algorithm described by M.M. Micheal includes an optimized version which
has not been implemented here, as I can't make any assumptions on the 
structure of anything you might be using, nor its size.

Required System Features
========================
You need POSIX threads, because the algorithm uses thread-local data and I've
used the pthread API for that. Other than that, nothing special is required.

Note, though, that setting and unsetting hazard pointers is up to you and 
should be atomic operations.

