<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook V4.0//EN">
<refentry id="binomial_tree">

<refmeta>
<refentrytitle>libcontain-binomial_tree</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>

<refnamediv>
<refname>Binomial Tree</refname>
<refpurpose>Provide an API for an abstract binomial tree</refpurpose>
</refnamediv>

<refsect1>
<title>Description</title>
<para>This manpage describes the API of the binomial tree implementation for 
libcontain - the Jail-ust container library</para>
<para>While a binomial tree is not generally used directly as a container by
itself, it can be at the basis of the implementation of other containers such
as heaps or maps. The goal of this implementation is therefore not to provide an
easy-to-use implementation of a generic container with some kind of algorithmic
logic to handle the objects it contains, but to provide the basis to build other
containers on. Therefore, unlike most other containers, the API will provide 
access to individual nodes and will allow you to handle those nodes.</para>
</refsect1>

<refsect1>
<title>Synopsis</title>
<para><screen><![CDATA[
#include <libcontain/binomial_tree.h>

binomial_tree_t * binomial_tree_new(void);
void binomial_tree_free(binomial_tree_t * tree);
binomial_tree_node_t * binomial_tree_get_root(binomial_tree_t * tree);
int binomial_tree_set_root(binomial_tree_t * tree, binomial_tree_node_t * exp, binomial_tree_node_t * val);
binomial_tree_node_t * binomial_tree_node_new(void);
void binomial_tree_node_free(binomial_tree_node_t * handle);
binomial_tree_node_t * binomial_tree_node_get_left(binomial_tree_node_t * node);
binomial_tree_node_t * binomial_tree_node_get_right(binomial_tree_node_t * node);
int binomial_tree_node_set_left(binomial_tree_node_t * node, binomial_tree_node_t * exp, binomial_tree_node_t * nval);
int binomial_tree_node_set_right(binomial_tree_node_t * node, binomial_tree_node_t * exp, binomial_tree_node_t * nval);
binomial_tree_node_t * binomial_tree_node_get_parent(binomial_tree_node_t * node);
void binomial_tree_node_register(binomial_tree_node_t * node, int reg);
void binomial_tree_node_release(binomial_tree_node_t * node);
void * binomial_tree_node_get_value(binomial_tree_node_t * node);
int binomial_tree_node_set_value(binomial_tree_node_t * node, void * curr, void * val);
void binomial_tree_node_foreach(binomial_tree_node_t * root, binomial_tree_node_foreach_func_t func, void * data);
]]></screen></para>
</refsect1>

<refsect1>
<title>Functions</title>
<para>
<variablelist>

<!--
<varlistentry><term><function>
function name</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>
-->

<varlistentry><term><function>binomial_tree_t * binomial_tree_new(void)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>void binomial_tree_free(binomial_tree_t * tree)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>binomial_tree_node_t * binomial_tree_get_root(binomial_tree_t * tree)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>int binomial_tree_set_root(binomial_tree_t * tree, binomial_tree_node_t * exp, binomial_tree_node_t * val)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>binomial_tree_node_t * binomial_tree_node_new(void)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>void binomial_tree_node_free(binomial_tree_node_t * handle)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>binomial_tree_node_t * binomial_tree_node_get_left(binomial_tree_node_t * node)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>binomial_tree_node_t * binomial_tree_node_get_right(binomial_tree_node_t * node)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>int binomial_tree_node_set_left(binomial_tree_node_t * node, binomial_tree_node_t * exp, binomial_tree_node_t * nval)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>int binomial_tree_node_set_right(binomial_tree_node_t * node, binomial_tree_node_t * exp, binomial_tree_node_t * nval)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>binomial_tree_node_t * binomial_tree_node_get_parent(binomial_tree_node_t * node)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>void binomial_tree_node_register(binomial_tree_node_t * node, int reg)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>void binomial_tree_node_release(binomial_tree_node_t * node)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>void * binomial_tree_node_get_value(binomial_tree_node_t * node)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>int binomial_tree_node_set_value(binomial_tree_node_t * node, void * curr, void * val)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

<varlistentry><term><function>void binomial_tree_node_foreach(binomial_tree_node_t * root, binomial_tree_node_foreach_func_t func, void * data)</function></term>
<listitem><para>one-liner function description</para>
<para>more verbose function description</para>
<para>info pertaining thread-safety</para>
</listitem></varlistentry>

</variablelist>
</para>
</refsect1>

<refsect1>
<title>Helper functions</title>
<para>The binary tree uses only one callback function, of type <function>binomial_tree_node_foreach_func_t</function>. This function is called for each non-NULL value stored in the tree as of the given root node, and is handed the function's data parameter as well as the value of the node.</para>
</refsect1>

<refsect1>
<title>Thread Safety</title>
<para>There are no locks on the nodes in the binary tree, nor are there any on
the tree itself. However, that doesn't mean the binary tree implementation is
not thread-safe: it has been designed to use only atomic writes and the API is
rich enough to do just about anything with the tree, atomically.</para>
<para>As the binomial tree implementation does not implement any of the 
algorithmic logic needed to implement an actual container, most of the 
thread-safety concerns lie with the user. The restrictions on the API do allow
for the implementation of non-blocking thread-safe containers, however: for 
example: new nodes are created whenever a non-existant node is asked for. That
may be the root of the tree or a child of a leaf node. Hence, the way to 
recognize a leaf node is to check whether both of its children are empty (i.e.
don't contain a value). Though that makes for two extra nodes to allocate, 
that also takes the allocation and grafting of nodes on the tree away from the
<quote>client</quote> implementation. Grafting a node onto any place in the
tree is impossible if you do not know what the current child node is: you can't
simply cut off a branch of the tree without knowing it.</para>
<para>All the write operations on the nodes are atomic and it is impossible to
replace a value on a node without first knowing the current value of the node.
hence, it is impossible to mistakenly remove a value from the tree unless the 
client code is really messed up.</para>
</refsect1>

<refsect1>
<title>Bugs</title>
<para>Certainly there are some.. you tell me!</para>
</refsect1>

</refentry>
